\chapter{Конструкторский раздел}
\label{cha:design}

В данном разделе на основе проведенного анализа описывается взаимодействие между подсистемами, выделяются основные составляющие в каждой системе и проектируется их взаимодействие.

\section{Подсистема сбора данных}
\subsection{Очередь задач}
Сообщения, наряду с блоками вычисления и хранения, составляют три основных блока почти в каждой блок-схеме системы. Очереди сообщений, по существу, являются связующим звеном между различными процессами в приложениях и обеспечивают надежный и масштабируемый интерфейс взаимодействия с другими подключенными системами.
Очередь - структура данных с различной дисциплиной доступа к элементам.
Модно выделить основные моменты при работе с очередью:
\begin{enumerate}
  \item На каждый из планировщиков поступает поток работ (заявок);
  \item Формируются очереди работ;
  \item Имеется ресурс, способный выполнить соответствующую работу;
  \item Обслуживание без отказа - заявка не покидает систему пока не будет выполнена. (среднее время обслуживания заявок в системе (очереди) не зависит от дисциплины обслуживания);
  \item Заявки имеют параметры:
  \begin{enumerate}
  	\item время обслуживания (трудоемкость);
  	\item приоритет;
	\end{enumerate}
  \item Выбор заявок из очереди производится по правилу, которое называется дисциплиной обслуживания.
\end{enumerate}

В целом области применения очередей сообщений включают в себя:

\begin{itemize}
  \item Обработку данных;
  \item Буферизацию потоков данных;
  \item Управление процессами;
  \item Интеграцию и взаимодействие систем.
\end{itemize}

\subsection{Использование очереди сообщений}

Десять причин, почему очереди сообщений являются жизненно важным компонентом для любой архитектуры или приложения:
\paragraph{Слабое связывание} - очереди сообщений создают неявные интерфейсы обмена данными, которые позволяют процессам быть независимыми друг от друга т.е вы просто определяете формат сообщений отправляемых от одного процесса другому.
\paragraph{Избыточность} - Очереди позволяют избежать случаев неэкономного использования ресурсов процесса(например памяти) в результате хранения необработанной (лишней информации) информации.
\paragraph{Масштабируемость} - очереди сообщений позволяют распределить процессы обработки информации. Таким образом, они позволяют легко наращивать скорость, с которой сообщения добавляются в очередь и обрабатываются.
\paragraph{Эластичность} и возможность выдерживать пиковые нагрузки - очереди сообщений могут выполнять роль своего рода буфера для накопления данных в случае пиковой нагрузки, смягчая тем самым нагрузку на систему обработки информации и не допуская ее отказа.
\paragraph{Отказоустойчивость} - очереди сообщений позволяют отделить процессы друг от друга, так что если процесс, который обрабатывает сообщения из очереди падает, то сообщения могут быть добавлены в очередь на обработку позднее, когда система восстановится.
\paragraph{Гарантированная доставка} - использование очереди сообщений гарантирует, что сообщение будет доставлено и обработано в любом случае (пока есть хотя бы один обработчик).
\paragraph{Гарантированный порядок доставки} - большая часть систем очередей сообщений способны обеспечить гарантии того, что данные будут обрабатываться в определённом порядке (чаще всего в том порядке в котором они поступили).
\paragraph{Буферизация} - очереди сообщений позволяет отправлять и получать сообщения при этом работая с максимальной эффективностью, предлагая буферный слой - процесс записи в очередь может происходить настолько быстро, насколько быстро это в состоянии выполнить очередь сообщений, а не обработчик сообщения.
\paragraph{Понимание потоков данных} - очереди сообщений позволяют выявлять узкие места в потоках данных приложения, легко можно определить какая из очередей забивается, какая простаивает и определить что необходимо делать - добавлять новых обработчиков сообщений или оптимизировать текущую архитектуру.
\paragraph{Асинхронная связь} - очереди сообщений предоставляют возможность асинхронной обработки данных, которая позволяет поместить сообщение в очередь без обработки, позволяя системе обработать сообщение позднее, когда появится возможность

При разработке очереди выполнения задач можно пойти двумя путями: использовать для работы существующие решения, или разработать собственное решение. Рассмотрим оба варианта.


\subsection{Дисциплина обслуживания}

Бесприоритетные ДО
\begin{itemize}
  \item линейные:
  \begin{enumerate}
	  \item в порядке поступления (FIFO);
	  \item в инверсном порядке (LIFO);
	  \item случайный выбор (RAND);
  \end{enumerate}
  \item циклические ДО:
  \begin{enumerate}
	  \item циклический алгоритм (RR);
	  \item многоуровневый циклический алгоритм (FB);
	  \item смешанный алгоритм.
  \end{enumerate}
\end{itemize}
БДО - выбирают заявки без учета их важности, например, по признаку последовательности поступления.
Линейные ДО характеризуются одинаковым среднем временем ожидания не зависимо от длительности заявки (т.е. трудоемкости).
\begin{enumerate}
	\item Линейные ДО характеризуются одинаковым средним временем ожидания.
	\item Циклические ДО обслуживают короткие заявки с неявным приоритетом.
	\item Бесприоритетые ДО не требуют предварительной информации о длительности заявок.
	\item Уменьшение длительности ожидания коротких заявок происходит за счет увеличения tожид. длинных заявок.
\end{enumerate}

Приоритетные ДО:
\begin{itemize}
  \item с фиксированным приоритетом:
  \begin{enumerate}
	  \item ДО с относительным приоритетом (ОП);
	  \item с абсолютным приоритетом (АП);
	  \item адаптивное обслуживание;
  \end{enumerate}
  \item с динамическим приоритетом:
  \begin{enumerate}
	  \item в зависимости от $t_{\text{ожид.}}$;
	  \item в зависимости от $t_{\text{обсл.}}$.
  \end{enumerate}
\end{itemize}

На рисунке 2.1 представлена схема одноканальной системы без отказов.
\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/design2-1}
  \caption{Одноканальной системы без отказов}
  \label{fig:fig01}
\end{figure}

Поскольку анализ предметной области показал, что в данной работе мы будем использовать очередь с относительными приоритетами, рассмотрим именно её.
На рисунке 2.2 представлена схема многоканальной системы с относительными приоритетами.
\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/design2-2}
  \caption{Многоканальной системы с относительными приоритетами}
  \label{fig:fig02}
\end{figure}

\subsection{Существующие решения} 

\paragraph{Apache ActiveMQ} - открытая реализация брокера сообщений (Message Broker) и Enterprise Integration Patterns (если сейчас и очень кратко - расширение для реализации дополнительной обработки согласно правилам). Этот проект, самый мощный и развивающийся, недавно вышла версия 5.1. Он реализовывает множество стандартов и обеспечивает все возможности, необходимые для решений уровня Enterprise, входит в стек Java-технологий от Apache. Наиболее интересная возможность - это возможность кросс-языкового обмена сообщениями, а значит - клиенты могут быть реализованы на любом языке. Для платформ Java, C, C++, C\# это библиотека OpenWire, реализующая Wire протокол для нативного доступа к MQ, для остальных языков есть Stomp - реализация библиотек для разных скриптовых языков, которая превращает сообщения в формат JMS. Если необходимо обеспечить безопасную коммуникацию и передачу сообщений, можно использовать SSL.

\paragraph{MQS (Minimalist Queue Services)} - проект, если можно так сказать, с друго конца. Это небольшая система, написанная на Perl, организовывает систему очередей сообщений, используя XML-RPC протокол, сами сообщения могут хранится как в любой базе данных, так и в файлах. К сожалению, по всей видимости, проект заброшен, так как последняя новость на сайте датирована апрелем 2005 года, а текущая версия - 0.0.14.

\paragraph{Spread} - еще одна реализация очереди сообщений, на этот раз на С++, и версии есть для различных платформ, включая Win32, Linux, BSD и MacOS. Текущая версия - 4.0. Система распределенная и ориентирована на высокопроизводительные системы, где клиентов и, соответственно, сообщений, очень много. Заявлена поддержка, в последней 4.0 версии, технологии Virtual Synchrony. Что интересно - в поставку сразу включены бинарные версии для нескольких платформ, а также встроенные интерфейсы для некоторых языков - C/C++, Java, Perl, Python, Ruby.

\paragraph{RabbitMQ} - высокопроизводительная платформа, написанная на Erlang, основанная на Open Telecom Platform, а значит - очень надежная и масштабированная система, часто применяемая в телекоммуникационных приложениях и других подобных системах. Есть интерфейс только для Java и C++. Система поддерживает стандарт AMQP (Open Standard for Messaging Middleware). Система интересная, на этой же платформе написан самый популярный Jabber-сервер ejabberd, который также можно применять в он-лайн игровых проектах.

\subsection{Разработка подсистемы обработки задач} 
Рассмотренные выше системы являются хорошими инструментами для организации очереди сообщений для масштабирования системы, путем создания асинхронных связей между ее подсистемами. Такая архитектура отлично подходит для распределения процессов в системе их разрушения связанности компонентов. В первом приближения одно из таких систем может быть выбрана в качестве менеджера очереди для решаемой задачи, но такие требования как приоритеты задача, сохранение статусов и информации о заявках в системе, хранение статистики и другие приводят к идее реализации очереди на основе набора заявок в некоторой базе данных, менеджера очереди и обработчиков заявок.

Данная подсистема является системой массового обслуживания с дисциплиной обслуживания многоканальной очереди с относительными приоритетами, что приводит к следующим выводам:

\begin{enumerate}
	\item Система должна обладать некоторым хранилищем заявок, при этом заявки должны быть дифференцированы по типу задач и приоритету;
	\item Выборкой заявок из очереди, постановкой новых задач, а так же отправкой задач на исполнение должна заниматься некоторая система управления очередью;
	\item Для каждой заявки, подтупившей на выполнение должен создаваться нескорый обработчик, который реализует исполнение заявки в соответствии с некоторому правилами.
	\item После обработки заявка и должна отправиться менеджеру очереди, для  назначения ей очередного статуса либо удаления из системы.
\end{enumerate}
Поскольку суть обработки заявок заключается в получении некоторого документа и в большинстве случаев его дальнейшего разбора, обработчик заявки должен состоять из некоторого http-клиента и парсера документов.

\begin{figure}
  \centering
  \includegraphics[width=170mm]{inc/dia/design2-3}
  \caption{Подсистема сбора данных}
  \label{fig:fig03}
\end{figure}

\subsection{Исполнение заявки}
В общем случае, попадая в систему, заявка проходит следующие этапы в процессе исполнения:
\begin{enumerate}
	\item Заявка попадает в систему;
	\item Заявка получает приоритет в соответствии с установленными правилами для данного типа заявки;
	\item После ожидания в очереди задача выбирается на выполнение модулем управления;
	\item Обработчик пытается получить данные с определенного в заявке адреса;
	\item В случае успеха обработчик разбирает полученный документ и ищет необходимые данные в соответствии с заданными правилами обработки, а в случае неудачи, заявка снова ставится в очередь для повторного выполнения;
	\item Если данные в документе найдены, то они отправляются на дальнейшую обработку, если нет, система оповещает об этом событии, а задача удаляется из очереди;
	\item В случае, если после выполнения этой задачи, все данные по документу найдены, они отправляются в базу данных;
	\item Если в документе найдена ссылка для дальнейшего разбора, в очередь ставится новая задача.
\end{enumerate}

После нахождения в состоянии ожидания в очереди, заявка попадает на обработку в соответствие с вобранной дисциплиной обслуживания очереди. В случае очереди с относительными приоритетами такая заявка будет поставлена на обслуживание после того, как в очереди не будет заявок с более высоким приоритетом, а данная заявка будет иметь наибольшее время ожидания в очереди.

После того как заявка выбирается из очереди, она попадает в обслуживающий аппарат. В обслуживающем аппарате заявка проходит несколько стадий выполнения в зависимости от типа заявки. Поскольку главной задачей подсистемы является сбор данных, первым этапом является получение документа из сети. Реализация данного процесса выполняется путем использования некоторого сетевого клиента, реализация которого зависит от протокола передачи данных (в нашем случае протокол прикладного уровня HTTP). В случае успешной попытки получения, данные передаются в модуль разбора документа, если того требует логика обработки заявки, либо сразу отправляется в постобработчик для завершения разбора. 

В модуле разбора данных, специфичном для каждого типа задач, происходит процесс поиска и выборки данных из документа. В случае работы с документами, представленными в формате HTML это могут быть CSS-селекторы или выражения XPath, в случае документов XML - XPath, в случае JSON-документа - стандартные средства языка для работы с JSON-объектами. Рассмотренные форматы являются наиболее популярными форматом представления данных в сети, но при необходимости может быть создан специфичный модуль разбора документа, например, для разбора документов в формате doc, flash-документов и других. Полученные после разбора данные являются результатом обработки заявки.

В случае, если документ не требует последующей обработки, например получено изображение в формате jpeg, PDF документ или видео, эти данные и служить результатом работы модуля.

После завершения работы над задачей данные поступают в постобработчик для их сохранения, либо создания новых заявок. Типичным результатом обработки заявки по сбору некоторых ссылок на сайте является набор URL-адресов для дальнейшего разбора. Такой набор приходит на вход постобработчика, который в свою очередь создает по каждому адресу новую заявку на выполнение и передает сформированные заявки в модуль управления очередью для их последующей постановки в очередь.

Данный алгоритм представлен на рисунке 2.4.
\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/design2-4}
  \caption{Алгоритм обработки заявки}
  \label{fig:fig04}
\end{figure}

На рисунке 2.5 представлена диаграмма последовательности процесса обработки задачи.

\begin{figure}
  \centering
  \includegraphics[width=150mm]{inc/dia/design2-6}
  \caption{Диаграмма последовательности процесса обработки заявки}
  \label{fig:fig06}
\end{figure}

\subsection{Состояние заявки}
В процессе жизни заявка может находиться в нескольких состояниях в зависимости от этапа или результатов выполнения. Так, вновь поступившая или в очередной раз поставленная в очередь заявка находится в состоянии ожидания и готова к выполнению как только обслуживающий аппарат освободится и текущая заявка получит ресурсы для исполнения в соответствие со своим приоритетом. Такая заявка может быть выбрана менеджером очереди для последующего выполнения согласно с дисциплиной обслуживания очереди. После попадания в обработчик, заявка находится в стадии выполнения. В зависимости от результатов обработки, заявка может либо быть удалена из очереди, в случае, если она успешно обработана, поставлена в очередь для повторный обработки, в случае неудачного выполнения. При этом она может быть либо выбрана в любой момент после очередного попадания в очередь, либо поставлена в очередь для отложенного выполнения. После некоторого количества неудачных повторений, задаваемых на этапе настройки системы, заявка может быть отменена.

Диаграмма состояний заявки представлена на рисунке 2.5.

\begin{figure}
  \centering
  \includegraphics[width=150mm]{inc/dia/design2-5}
  \caption{Диаграмма состояний заявки}
  \label{fig:fig05}
\end{figure}

\subsection{Скачивание и разбор документа}

Главной задачей подсистемы является сбор информации, поэтому сердцем ее является модуль получения и разбора документа. 

На вход модуля выполнения любой задачи подается заявка определенного формата. Среди прочих данных, определяющих ее состояние, тип и др., содержится и адрес некоторого документа в сети. За получение этого документа отвечает некоторый программный http-клинт, задачей которого является подключения по заданному URL и получение документа. Параметрами клиента так же являются время ожидания подключения и получения документа. При превышении заданных величины на соответствующих стадиях выполнения выбрасывается исключение и заявка считается не выполненной. Такая заявка отправляется в менеджер очереди, где снова ставится на выполнение либо удаляется из системы. После успешного получения документа наступает стадия разбора.

За разбор документа отвечает класс парсера. Парсер представляет собой некоторый конкретный класс, предоставляющий своим клиентам интерфейс Parser с единственным открытым методом parse. Конкретный класс обязан переопределить этот метод и задать в нем правила разбора документа для поиска в нем полезных данных. Тип парсера и правила разбора зависят от типа задачи, а так же типа разбираемого документа. На вход объекта поступает документ в том виде, в котором он был получен из сети. В случае успешной попытки разбора, данные передаются дальше на вход постобработчика. Если, по какой-то причине, данные в документе не найдены, заявка передается в менеджер очереди, где происходит ее удаление из системы. 

Так как формат представления документа на стороне источника может измениться, либо документ может быть полностью заменен или удален, администратор системы должен своевременно уведомляться о подобных проблемах, а так же о проблемах, связанных с получением данных. Своевременное устранение возникающих проблем поможет ускорить процесс разбора, а так же освободить очередь от постоянных попыток получения заведомо проблемных документов.

Диаграмма данного процесса представлена на рисунке 2.7.
\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/design2-7}
  \caption{Диаграмма последовательности разбора документа}
  \label{fig:fig07}
\end{figure}

В случае, если документ не нуждается в разбое, например при получении изображения, документа Microsoft Office Word или PDF документа, модуль разбора не участвует в процессе обработке, а полученный документ сразу передается в постобработчика для дальнейших действий.


\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/design2-8}
  \caption{Диаграмма классов}
  \label{fig:fig08}
\end{figure}

Правила парсера для разбора представляют из себя код для разбора DOM полученного документа. Для разбора документа, представленного в HTML используются селкторы CSS для поиска элементов на странице. Для формата XML может быть использована технология XPath.

Простейший пример поиска элемента представлен в листинге 1.1.

\begin{lstlisting}[caption=Поиск ссылок на странице]
def parse page, domain
  page.search("td.score a").map do |link|
    Rails.logger.info link[:href]
    domain + link[:href].gsub(/preview|report/, "stats")
  end
end
\end{lstlisting}

К сожалению, не все документы в сети являются размеченными в соответствии с назначением языка разметки HTML и семантикой элементов языка для облегчения представления данных. Данный случай является грубым нарушением принципа отделения данных от представления. 

\begin{lstlisting}[caption=Разбора статистики матча]
def parse page
  result = {
      :clubs => {
          :home => page.search(".club.home").text,
          :away => page.search(".club.away").text
      },
      :stats => {
          :home => Hash[],
          :away => Hash[]
      }
  }
  table = page.search(".statsTable")
  table.search("thead tr").each do |tr|
    tr.search("th:not(:first-child)").each_with_index.map do |th, j|
      result[:stats][:home][th.text.to_sym] = tr.parent.parent.search("tbody td:eq(#{j + 1})")[0].text.to_i
      result[:stats][:away][th.text.to_sym] = tr.parent.parent.search("tbody td:eq(#{j + 1})")[1].text.to_i
    end
  end
  result
end
\end{lstlisting}

Данные правила задаяются в классах, наследующих от класса Parser и реализующих его интерфейс. Единственным методом данного интерфейса является метод parse. Именно этот метод и реализует разбор документа и поиск необходимых данных в нем. Каждый класс создается отдельно для определенного сайта и разбора определенного документа, разбираемого при исполнении заявки определенного типа. Поскольку форма представления данных в сети является целиком и полностью в ведении владельцев предоставляющих данные документы, система не может рассчитывать на то, что формат представления всегда будет неизменным и должна своевременно уведомлять администратора системы обо всех происходящих изменениях на стороне источника. Но поскольку изменение формата является довольно редким явлением, данная проблема носит временный и не контролируемый характер. В случае появления таких изменений, придется изменить лишь правила разбора в одном из классов, что в свою очереди на практике выливается чаще всего в изменение одной строчки CSS-селектора. Таким образом, данная система является легко поддерживает и требует лишь знание основ представления документов и объектной модели документа. 

\subsection{Потоки выполнения}
Данная система рассчитана на сбор больших объемов данных. При этом заявки имеют разный приоритет и заявки выбираются из очереди в соответствие с их приоритетом. При большом объеме заявок, хранящихся в очереди, заявки с меньшим приоритетом могут находится в очереди на протяжении большого времени и сбор данных станет долгим процессом. Так же продолжительное время разбора не приемлемо при сборе данных о матча в реальном времени(<<live>>) в соответствие с требованиями к системе. Для повышения производительности системы и ускорения скорости разбора можно распараллелить выполнение заявок. Лучше всего для это использовать отдельные потоки выполнения задач. При этом возникает ряд проблем, связанных с синхронизацией потоков и большим количеством HTTP-запросов. 

При работе системы в несколько потоков появляется проблема работы менеджера очереди, связанная с выборкой задач на выполнения. Так, при попытке выбрать очередную задачу из очереди на выполнение, необходимо быть уверенным в том, что одна и та же задача не будет выполняться в нескольких потоках. Для решения этой проблемы существует два подхода. Первым из них является блокировка базы данных в потоке на время выборки очередной задачи, второй является атомарная выборка заявки из очереди. Первый вариант является более сложным в реализации и накладным вариантом при работе с СУБД, поскольку приходится блокировать всю таблицу на время поиска заявки. Второй вариант является более простым, но реализован не во всех СУБД.

Второй проблемой является большое число запросов к сайтам, предоставляющим интересующую нас информацию. В зависимости от настроек безопасности сервера, на котором находится необходимый нас документ, большое число запросов к серверу с одного IP-адреса может привести к тому, что сервер перестанет отдавать в ответ запрашиваемый документ и вернет некоторую ошибку в соответствии со спецификацией протокола HTTP. Данную проблему можно решить с помощью проксирования запросов.

\subsection{Проксирование запросов}

Прокси-сервер (от англ. proxy — «представитель, уполномоченный») — служба (комплекс программ) в компьютерных сетях, позволяющая клиентам выполнять косвенные запросы к другим сетевым службам. Сначала клиент подключается к прокси-серверу и запрашивает какой-либо ресурс (например, HTML-документ), расположенный на другом сервере. Затем прокси-сервер либо подключается к указанному серверу и получает ресурс у него, либо возвращает ресурс из собственного кэша (в случаях, если прокси имеет свой кэш). В некоторых случаях запрос клиента или ответ сервера может быть изменён прокси-сервером в определённых целях. Также прокси-сервер позволяет защищать клиентский компьютер от некоторых сетевых атак и помогает сохранять анонимность клиента.

Использование прокси-серверов для выполнения запросов поможет решить проблему частого обращения на адреса одного сервера. Для этого можно использовать список анонимных прокси-серверов и каждый запрос выполнять с использованием одного из них. Так, web-клиент в качестве аргумента принимает адрес и тип прокси-сервера перед очередным запросом и ведет запрос к источнику данных через прокси, скрываю IP-адрес нашего сервера. Таким образом, каждый запрос будет идти с "разных" серверов, и наш сервер не будет занесен в "черный" список клиентов. 

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/design2-9}
  \caption{Использование прокси-сервера}
  \label{fig:fig09}
\end{figure}

В сети существует большое количество сервисов, предоставляющих списки прокси-серверов. Для работы с прокси необходимо написать скрипт, который будет получать список, записывать его в файл и проверять полученные адреса. Существуют решения для проверки прокси-серверов, одним из которых является программа proxyknife. На вход она получает путь к файлу со списком серверов, проходит по списку осуществляя запросы на тестовый сервер с проверкой IP-адреса клиента, а результат работы записывает в выходной файл. Таким образом на выходе мы получает список проверенных анонимных прокси-серверов готовых к использованию. Такая проверка производится несколько раз в минуту.

Но при использовании прокси-серверов возникает проблема частой "смерти" прокси. Обычно такие серверы часто попадают в черный список сайтов или становятся недоступными по иным причинам. Для решения этой проблемы можно использовать рейтинг прокси-серверов. Для ведения такого рейтинга необходимо вести список серверов по нескольким критериям:

\begin{itemize}
\item список новых серверов;
\item список всех полученных серверов;
\item список всех полученных серверов с рейтингом;
\item список работающих/неработающих серверов;
\item список работающих/неработающих серверов с рейтингом;
\item список серверов с количеством использований;
\end{itemize}

Эти списки используются для обновления рейтинга после каждой отработки скрипта получения списка прокси-серверов, а так же при каждом использовании отдельного сервера. При каждом новом получении файла рабочих серверов создается временный список новых серверов. После этого проводится объединение вновь созданного списка со списками всех уже собранных серверов, онлайн серверов, серверов с попытка успешного и не успешного использования. Затем для полученных серверов обнуляется число неудачных попыток использования, формируется временный список оффлайн серверов и затем список очищается. Далее по списку оффлайн серверов обновляется количество неудачных попыток тестирования полученного адреса и список удаляется. Используя этот список, находятся те серверы, число попыток обращения по которым превысил некоторый предел. Эти серверы удаляются из списка онлайн серверов, а список попыток использования обнуляется.

За этим следует процесс формирования рейтинга, который построен на использовании информации о частоте удачного и неудачного использования прокси-сервера, которая берется из соответствующих списков. Списки использования обновляются после каждого выполнения очередной заявки в соответствии с результатом запроса к серверу. В случае получения запрашиваемого документа, счетчик удачного использования сервера увеличивается, а в случае неудачно запроса увеличивается счетчик ошибки сервера. По этим спискам для уже использовавшихся в системе серверов обновляется процентное значение эффективности работы прокси-сервера, а для вновь полученных выставляется начальное значение эффективности, которое обновляется в процессе работы системы, по вышеописанному алгоритму. Данный алгоритм представлен на рисунке 2.10.

Главным этапом в использовании прокси-серверов является поддержание рейтинга в актуальном состоянии. Поскольку один сервер может вести себя по-разному при последовательных запросах, необходимо вести учет того, сколько раз он оказался работоспособен или, наоборот, вернул ошибку. Так, при каждом использовании для каждого сервера обновляется счетчик успещного/ошибочного ответа в зависимости от результата работы. Для сведения к минимуму использование не отвечающих/заблокированных прокси-серверов, можно выбирать серверы, которые чаще успешно отвечают при очередном запросе. То есть, необходимо, чтобы вероятность выборки более эффективных серверов была выше. 
\begin{figure}
  \centering  
  \includegraphics[width=\textwidth]{inc/dia/design2-10}
  \caption{Обновление рейтинга прокси-серверов}
  \label{fig:fig09}
\end{figure}
При этом, чем чаще выбирается сервер, тем больше у него оказаться на вершине списка. С другой стороны, в случае, если сервер перестает отвечать, он быстро уходит вниз по рейтингу, и реже попадает в выборку для использования. Для вновь поступивших серверов задается некое среднее значение эффективности, для того чтобы они попадали в выборку достаточно часто, чтобы переместиться по списку в направлении, соответствующему эффективности этого сервера.

Для выборки прокси-серверов следует использовать экспоненциальный закон распределения. График плотности вероятности этого распределения выглядит следующим образом:

\begin{figure}
  \centering  
  \includegraphics[width=140mm]{inc/dia/exponent}
  \caption{Плотность вероятности экспоненциального распределения}
  \label{fig:exponent}
\end{figure}

 Функция этого распределения:

\begin{equation}
F(x) = 1 - e^{-\lambda x}
\label{F:F2}
\end{equation}

Её обратная функция имеет следующий вид:

\begin{equation}
F^{-1}(x) = -\frac{1}{\lambda}\ln(1 - x)
\label{F:F2}
\end{equation}

Таким образом искомая выборка из экспоненциального распределения:

\begin{equation}
X_i = -\frac{1}{\lambda}\ln(1 - U_i), i = 1,..,n, где
\label{F:F2}
\end{equation}

$X_{\text{1}}$,...,$X_{\text{n}}$ - искомый индекс прокси-сервера из рейтинга, $U_{\text{1}}$,...,$U_{\text{n}}$ - выборка из стандартного непрерывного равномерного распределения.

Метод получения индекса представлен в листинге 2.3

\begin{lstlisting}[caption=Выборка прокси-сервера]
def rnd(max = 100)
  rate = 2 * Math::PI / max
  rand_val = rand(MAX_INT) / MAX_INT.to_f
  res = -Math::log(rand_val) / rate
  (res < max) ? res.to_i  : 0
end
\end{lstlisting}

\subsection{Модель данных}

В данном разделе представлена модель данных, используемых для реализации очереди заявок, и сущностей, связанных с ней. Формат заявки представлен в листинге 2.4. 
\begin{lstlisting}[caption=Заявка]
{     
      "type": "Тип задачи",
    "data": "Дополнительные данные необходимые для выполнения задачи",
    "created_at" : "Время создания задачи",
    "updated_at" : "Время последней попытки исполнения",
    "status" : "Текущий статус задачи",
    "attempts" : "Количсество попыток выполнения текущей"
}
\end{lstlisting}


\begin{figure}
  \centering  
  \includegraphics[width=\textwidth]{inc/dia/design2-11}
  \caption{Диаграмма сущность-связь модели данных системы сбора заявок}
  \label{fig:11}
\end{figure}

\subsection{Web-интерфейс администрирования}

\begin{figure}
  \centering  
  \includegraphics[width=\textwidth]{inc/dia/design2-12}
  \caption{Диаграмма прецедентов}
  \label{fig:11}
\end{figure}
\section{Подсистема управления данными}

\section{Клиентское приложение}

\section{Сервер <<live>>}

\paragraph{Проверка} параграфа. Вроде работает.
\paragraph{Вторая проверка} параграфа. Опять работает.

Вот.

В \cite{Pup09} указано, что...

\begin{itemize}
\item Это список с <<палочками>>.
\item Хотя он и не по ГОСТ, кажется.
\end{itemize}

\begin{enumerate}
\item Поэтому для списка, начинающегося с заглавной буквы, лучше список с цифрами.
\end{enumerate}

Формула \ref{F:F1} совершено бессмысленна.

%Кстати, при каких-то условиях <<удавалось>> получить двойный скобки вокруг номеров формул. Вопрос исследуется.

\begin{equation}
a= cb
\label{F:F1}
\end{equation}


Окружение \texttt{cases} опять работает (см. \ref{F:F2}), спасибо И. Короткову за исправления..


\begin{equation}
a= \begin{cases}
 3x + 5y + z, \mbox{если хорошо} \\
 7x - 2y + 4z, \mbox{если плохо}\\
 -6x + 3y + 2z, \mbox{если совсем плохо}
\end{cases}
\label{F:F2}
\end{equation}

\section{Подсистема всякой ерунды}

Культурная вставка dot-файлов через утилиту dot2tex (рис.~\ref{fig:fig02}).

% \begin{figure}
%   \centering
% % [width=0.5\textwidth] --- регулировка ширины картинки
%   \includegraphics{inc/dot/cow2}
%   \caption{Рисунок}
%   \label{fig:fig02}
% \end{figure}


\subsection{Блок-схема всякой ерунды}

\subsubsection*{Кстати о заголовках}

У нас есть и \Code{subsubsection}. Только лучше её не нумеровать.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "rpz"
%%% End:
